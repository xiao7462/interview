# 排序算法
![enter description here](https://i.loli.net/2019/10/18/jgkstL6W1AMIacu.png)

## 基础知识
1. 什么是稳定性
2. 有什么排序方式

## 插入排序


**java**
```java
/**
 * 插入排序
 * 直接插入排序：
 *  基本思想：
 *  在要排序的一组数中，假设前面(n-1)[n>=2] 个数已经是排
 *  好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数
 *  也是排好顺序的。如此反复循环，直到全部排好顺序。
 *
 *  直接插入排序是由两层嵌套循环组成的。外层循环标识并决定待比较的数值。
 *  内层循环为待比较数值确定其最终位置。直接插入排序是将待比较的数值与它的前一个数值进行比较，
 *  所以外层循环是从第二个数值开始的。当前一数值比待比较数值大的情况下继续循环比较，
 *  直到找到比待比较数值小的并将待比较数值置入其后一位置，结束该次循环。
 *
 *  时间复杂度：O(n2)
 *  空间复杂度：O(1)
 *  排序方式 :  in-place
 *  稳定性：稳定
 *
 */



public class Insert_Sort {
    public static void main(String[] args) {

        int arr[] = {1,4,6,8,2,5,3,7,9};
        System.out.println("数组排序前顺序：");
        for(int n : arr){
            System.out.print(n+" ");
        }

        //直接插入排序
        insertSort(arr);

        System.out.println("\n数组排序后顺序：");
        for(int n : arr){
            System.out.print(n+" ");
        }

    }

    //直接插入排序
    private static void insertSort(int[] arr){
        // {1,4,6,8,2,5,3,7,9}
        //{1,4,6,8,8,5,3,7,9}
        //外层循环确定待比较数值
        for (int i=1;i<arr.length;i++) {  //必须i=1，因为开始从第二个数与第一个数进行比较
            int temp = arr[i];  //待比较数值
            int j = i - 1;
            //内层循环为待比较数值确定其最终位置
            for (;j>=0 && arr[j]>temp;j--) {  //待比较数值比前一位置小，应插往前插一位
                //将大于temp的值整体后移一个单位   8>2
                arr[j+1] = arr[j];
            }
            arr[j+1] = temp; //待比较数值比前一位置大，最终位置无误
        }
    }
}


```


## 快速排序
==快速排序==：      
快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
[视频链接](https://www.bilibili.com/watchlater/#/av33835237/p21)

```java

/*
基本思想：
通过一趟排序把要数据分隔成独立的2部分，其中一部分的所有数据比另一部分的所有数据都要小，然后再按此方法对这2部分的数据分别进行快排，整个排序过程可以差用递归 。 每次可以取数组的第一个数字最为比较标准

平均时间复杂度：O(nlogn)
最优时间复杂度： O(nlogn)  最优情况是每一次都取到刚好平分整个数组
最差时间复杂度： O( n^2 )  最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)

空间复杂度： 就地快排的空间是O(1), 递归需要消耗空间，因此是：
最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况
最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况

*/

package algrithm;
import java.util.Arrays;
public class QuickSort {
    public static void main(String[] args) {
        int[]  arr = new int[] {5,6,2,21,5,2,2,1,1};
        quickSort(arr, 0 , arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
    public static void quickSort( int[] arr, int start, int end){
        if(start < end){
            //把数组中的第0个数作为标准数
            int temp = arr[start];
            // 记录需要排序的下标
            int low = start;
            int high = end;
            //循环找比标准数大的数和比标准数小的数
            while(low <high){
                //如果high大于temp数，则high--;
                while(low<high && arr[high] >= temp){
                    high--;
                }
                //{5,6,2,21,5,2,2,1,1}
                arr[low] = arr[high];
                //如果左边的数比temp数小
                while(low < high && arr[low]<temp){
                    low++;
                }
                arr[high] = arr[low];
            }
            // 把标准数赋值给低位置所在的元素
            arr[low] = temp;
            // 递归较小的数组
            quickSort(arr, start, low);
            // 递归教大的数组
            quickSort(arr,low+1, end);
        }
}
}

```
